## 정렬알고리즘
### 1. 버블정렬(Bubble Sort)
- 시간복잡도 : 하단 표 참고
- 공간복잡도 : O(n)
- 한 줄 정리 : 맨 처음 인덱스부터 시작되어 바로 옆의 인덱스와 크기를 비교하여 순서를 바꿔나가는 것.
### 2. 선택정렬(Selection Sort)
- 시간복잡도 : 하단 표 참고
- 공간복잡도 : O(n)
- 한 줄 정리 : 한 번씩 순회하면서 가장 큰수를 찾아 배열의 마지막 위치와 교환한다.
### 3. 삽입정렬(Insertion Sort)
- 시간복잡도 : 하단 표 참고
- 공간복잡도 : O(n)
- 한 줄 정리 : 현재 인덱스보다 아래 인덱스에 있는 배열 원소들 중에 자신의 인덱스를 찾아 넣어줌.
### 4. 합병정렬, 병합정렬(Merge Sort)
- 시간복잡도 : 하단 표 참고
- 공간복잡도 : O(2n)
- 한 줄 정리 : 분할정복(Divide and Conquer)방식으로 설계된 알고리즘. 큰 문제를 반으로 쪼개 문제를 해결해 나가는 방식. 분할은 배열의 크기가 1보다 작거나 같을 때까지 반복.
### 5. 퀵정렬(Quick Sort)
- 시간복잡도 : 하단 표 참고
- 공간복잡도 : O(log₂n)
- 한 줄 정리 : 분할정복(Divide and Conquer)방식을 통해 리스트를 정렬.
### 6. 힙정렬(heap Sort)
- 시간복잡도 : 하단 표 참고
- 공간복잡도 : O(n)
- 한 줄 정리 :최대 힙 트리나 최소 힙 트리를 구성해 정렬을 하는 방식을 통해 리스트를 정렬. 보통 우선수윈큐를 만들 때 주로 이용한다.
<br/>
<br/>
+) 최악의 상황(이미 리스트가 정렬되어 있는 경우)에서 퀵정렬은 시간복잡도가 O(n^2)까지 증가한다. 이 때문에 예전에 자바에서는 합병정렬을 기본 컬렉션 sort로 제공했다. 이후 자바에서는(단 openJdk는 확실치 않음) 퀵정렬(리얼환경에서 대부분 아주 빠른편임)의 장점은 살리고 단점을 보완하기 위해 삽입정렬과 합쳐진 정렬 알고리즘인 팀정렬을 기본 컬렉션 정렬로 제공하고 있다.
<br/>

![정렬](https://user-images.githubusercontent.com/18229419/62004026-e6458700-b15a-11e9-893a-851e87b5f6b5.png)

> 출처: https://github.com/sunghyunjo/TIL/blob/master/algorithm/sorting%20Algorithm.md

> 출처: http://blog.naver.com/PostView.nhn?blogId=kbs4674&logNo=220727498080
