# Redis
## Redis 개념
### Intro
- 약자: REmote DIctionary System
- 메모리 기반의 Key/Value Store 이다.
- Cassandra나 HBase와 같이 NoSQL DBMS로 분류되기도 하고, memcached와 같은 In memory 솔루션으로 분리되기도 한다.
- 성능은 memcached에 버금가면서 다양한 데이타 구조체를 지원함으로써 Message Queue, Shared memory, Remote Dictionary 용도로도 사용될 수 있으며, 이런 이유로 네이버 재팬의 LINE 메신져 서비스, StackOverflow, Blizzard, digg 등 여러 소셜 서비스에 널리 사용되고 있다.
- redis는 별도 서버로 구축돼 주서버와 지속적인 서비스를 주고 받는 방법이 효과적이다. 
- 요즘은 하나에 모든 것을 관리 운영하기 보다 각각의 기능, 필요에 따른 마이크로 서비스(Micro Service) 형태로 많이 운영되어진다. 

> 출처: https://bcho.tistory.com/654 [조대협의 블로그]

<br/>

### 1. Key/Value Store
- Redis는 기본적으로 Key/Value Store이다. 특정 키 값에 값을 저장하는 구조로 되어 있고 기본적인 PUT/GET Operation을 지원한다.

    ![key value table](https://t1.daumcdn.net/cfile/tistory/1377533B4FFBD9D105)
- 단, 이 모든 데이타는 메모리에 저장되고, 이로 인하여 매우 빠른 write/read 속도를 보장한다. 
- 그래서 전체 저장 가능한 데이타 용량은 물리적인 메모리 크기를 넘어설 수 없다. (물론 OS의 disk swapping 영역등을 사용하여 확장은 가능하겠지만 성능이 급격하게 떨어지기 때문에 의미가 없다.)
- 데이타 억세스는 메모리에서 일어나지만 server restart 와 같이 서버가 내려갔다가 올라오는 상황에 데이타를 저장을 보장하기 위해서 Disk를 persistence store로 사용한다.

<br/>

### 2. 다양한 데이타 타입
- 단순한 메모리 기반의 Key/Value Store라면 이미 memcached가 있다.
- redis가 Key/Value Store이지만 저장되는 Value가 단순한 Object가 아니라 다양한 자료구조를 갖는 다는 점에서 memcached와 큰 차이가 있다.
- redis가 지원하는 자료형은 크게 아래와 같이 5가지가 있다.

<br/>

- 1)String
  - 일반적인 문자열로 최대 512mbyte 길이 까지 지원한다.
  - Text 문자열 뿐만 아니라 Integer와 같은 숫자나 JPEG같은 Binary File까지 저장할 수 있다.
  - 명령어 : http://redis.io/commands#string

<br/>

- 2)Set
  - Set은 String의 집합이다. 여러개의 값을 하나의 Value 내에 넣을 수 있다고 생각하면 된다.
  - 블로그 포스트의 태깅(Tag)등에 사용될 수 있다.
  - Set간의 연산을 지원하는데, 집합인 만큼 교집합, 합집합, 차이(Differences)를 매우 빠른 시간내에 추출할 수 있다.
  - 삽입 순으로 정렬되어 있다.
  
  ![set](https://t1.daumcdn.net/cfile/tistory/1572E6364FFBD9FA07)
  - 명령어 : http://redis.io/commands#set

<br/>

- 3)Sorted Set
  - Set 에 "score" 라는 필드가 추가된 자료형이다.
  - score는 정렬을 위한 일종의 "가중치" 정도로 생각하면 된다.
  - Sorted Set에서 데이터는 오름 차순으로 내부 정렬되며, 정렬이 되어 있는 만큼 score 값 범위에 따른 쿼리(range query), top rank에 따른 query 등이 가능하다.
  
       ![sorted set](https://t1.daumcdn.net/cfile/tistory/111999394FFBDA1215)
  - 명령어 : http://redis.io/commands#sorted_set

- 4)Hashes
  - hash는 value내에 field/string value 쌍으로 이루어진 테이블을 저장하는 데이터 구조체이다.
  - RDBMS에서 PK 1개와 string 필드 하나로 이루어진 테이블이라고 이해하면 된다.
  
       ![hash](https://t1.daumcdn.net/cfile/tistory/140B503C4FFBDA2825)
  - 명령어 : http://redis.io/commands#hash

- 5)List
  - List는 String들의 집합으로 저장되는 데이터 형태로 Set과 유사하지만, 일종의 양방향 Linked List라고 생각하면 된다.
  - List 앞과 뒤에서 PUSH/POP 연산을 이용해서 데이타를 넣거나 뺄 수 있고, 지정된 INDEX 값을 이용하여 지정된 위치에 데이타를 넣거나 뺄 수 있다. 
  
       ![List](https://t1.daumcdn.net/cfile/tistory/206F833B4FFBDA4419)
  - 명령어 : http://redis.io/commands#list

- +) 데이터 구조체 총 정리!
  - 지금까지 간략하게 redis가 지원하는 데이터 구조체들에 대해서 살펴보았다. redis의 데이터 구조체의 특징을 다시 요약하면 아래와 같다.
    - Value가 일반적인 String 뿐만 아니라, Set,List,Hash와 같은 집합형 데이타 구조를 지원한다.
    - 저장된 데이타에 대한 연산이나 추가 작업이 가능하다. (합집합,교집합,RANGE QUERY 등)
    - Set은 일종의 집합, Sorted Set은 오름차순으로 정렬된 집합, Hash는 키 기반의 테이블, List는 일종의 링크드 리스트 와 같은 특성을 지니고 있다.
  - 이러한 집합형 데이타 구조 (set,list,hash)등은 redis에서 하나의 키당 총 2^32개의 데이타를 이론적으로 저장할 수 있으나, 최적의 성능을 낼 수 있는 것은 일반적으로 1,000~5,000개 사이로 알려져 있다.
  - 데이터 구조에 따른 저장 구조를 정리해서 하나의 그림에 도식화해보면 다음과 같다.
  
       ![데이터 구조에 따른 도식도](https://t1.daumcdn.net/cfile/tistory/202A37504FFBDA6026)
  
> 출처: https://bcho.tistory.com/654 [조대협의 블로그]

### 3. Persistence

### 4. Pub/Sub Model
### 5. Replication Topology
### 6. Expriation
### 7. Redis 설치

### +) DB 종류에는 RDBMS, NOSQL, IN-memory  방식이 있다.
1)  RDB
 - 관계형 데이터베이스, 개체 간의 관계가 필요하다.
 - 저장될 데이터의 모델에 대한 스키마(속성, 개체, 관계 제약조건 등)가 정확히 명시돼야 한다.
 - 확실한 처리를 위해 트랜젝션 처리 단위가 중요시 된다.
> 출처: https://ram2ram2.tistory.com/4 [나를 정리하는 공간]

2) NOSQL
- 특정 데이터 모델에 대해 특정 목적에 맞추어 구축되는 데이터베이스로서 유연한 스키마를 갖추고 있습니다.
- NoSQL 데이터베이스는 문서, 그래프, 키 값, 인 메모리 검색 등의 데이터를 액세스 및 관리하기 위해 다양한 데이터 모델을 사용한다.
- 이는 데이터 일관성 제약 일부를 완화함으로써 이루어진다.
- 4가지 특징
  - 유연성: NoSQL 데이터베이스는 일반적으로 유연한 스키마를 제공하여 보다 빠르고 반복적인 개발을 가능하게 해준다. 이같은 유연한 데이터 모델은 NoSQL 데이터베이스를 반정형 및 비정형 데이터에 이상적으로 만들어 준다.
  - 확장성: NoSQL 데이터베이스는 일반적으로 고가의 강력한 서버를 추가하는 대신 분산형 하드웨어 클러스터를 이용해 확장하도록 설계됐다.
  - 고성능: NoSQL 데이터베이스는 특정 데이터 모델(문서, 키 값, 그래프 등) 및 액세스 패턴에 대해 최적화되어 관계형 데이터베이스를 통해 유사한 기능을 충족하려 할 때보다 뛰어난 성능을 얻게 해준다.
  - 고기능성: NoSQL 데이터베이스는 각 데이터 모델에 맞추어 특별히 구축된 뛰어난 기능의 API와 데이터 유형을 제공한다.
> 출처: https://aws.amazon.com/ko/nosql/[AWS]

3) IN-MEMORY
 - 데이터를 HDD가 아닌 memory에 저장하는 기술
 - get, put을 이용하여 데이터를 넣고 뺄 수 있다.
 - 인 메모리 기반의 디비는 key:value의 형태로 저장이 된다.
 - 메모리는 휘발성, 캐싱 서버로 사용하기 위해 나왔다.
> 출처: https://jwprogramming.tistory.com/47?category=680195


## +)사용시 주의 할점
레디스는 인메모리에서 돌아가는 NoSQL 데이터베이스(DB)로 '멤캐시드'와 경쟁구도를 그려 왔다.

레디스의 특징은 '싱글 쓰레드'라는 점이다. 싱글 쓰레드는 1번에 1개의 명령어만 실행할 수 있다. 한 서비스에서 요청된 명령어에 대한 작업이 끝나기 전까진 다른 서비스에서 요청하는 명령을 못 받아들인다. 이 특성 때문에 레디스로 웹서비스를 관리할 경우 절대 쓰면 안 되는 명령어들이 몇 가지 있다. 저장된 모든 키를 보여주는 명령어(keys)나 모든 데이터를 소거하는 명령어(flushall) 등이다.

모든 키를 보여주거나 플러싱하는 명령어는 테스트 환경이나 소량의 데이터를 관리하는 시스템에서 모니터링하는 용도로만 써야 한다 며 실행 대상을 전수처리하기 때문에 점차 데이터를 쌓아가는 환경에서는 운영에 차질을 빚을 정도로 속도가 느려질 것이다.
이어 빠른 속도로 플러시라는 명령어를 지원하는 멤캐시드 때문에 사람들이 레디스에서도 이 명령어가 금방 처리될 거라 기대하기도 하는데 실제 작동하는 방식이 완전히 다르다. 이 명령어 수행 시간을 재 보면 멤캐시드는 항상 일정하게 1~2ms가 나오는데 레디스는 데이터 100만건 정도 기준으로 1초(1천ms)로 이미 훨씬 느리다, 이건 실패한 사용법 이다.

레디스는 인메모리DB라 빠른 속도가 강점이지만 큰 용량의 데이터를 담기엔 공간 제약이 크다. 그래서 실시간 처리는 인메모리에서, 보관은 디스크 기반 스토리지로 하는 구조가 성능과 효율을 함께 달성할 수 있다. 트위터, 인스타그램, 페이스북처럼 대규모 사용자 기반을 갖춘 인터넷 서비스 업체들도 이런 식으로 서비스를 설계했다.

 레디스는 32비트 환경에선 최대 3GB 메모리만 사용 가능하고 64비트 시스템에서는 그런 제약이 없어 운영체제(OS)의 가상메모리(스왑)까지 쓴다. 하지만 이 경우 시스템의 메모리 한계를 인식하지 못해 더 많은 메모리를 요구하다가 문제를 일으킬 수 있어 관리자가 따로 설정을 더해줘야 한다.

 레디스는 멤캐시드에서 지원 안 하는 명령어 '콜렉션'을 지원하지만 앞서 '플러시올'이나 '키즈'같이 싱글쓰레드 방식에서 쓰지 말아야 하는 기능에 해당한다. 콜렉션에 데이터 100만건을 넣으면 처리시간이 10초, 1천만건 넣으면 100초씩 걸리는 식으로 늘어나기 때문에 굳이 쓰려면 일단 데이터를 1만건 미만으로 관리해야 한다.

이어 레디스에서 디스크에 메모리 상태를 그대로 받아 저장하는(메모리스냅숏) RDB 기능이 레디스 서버 장애요인 99.9%를 차지한다 며 원한다면 이 기능을 그냥 꺼 둘 수 있다.

 아마존 웹서비스 서버 기준으로 60GB짜리 메모리 서버 테스트시 RDB 작업에 10분 정도가 걸린다. 싱글쓰레드 문제를 겪지 않기 위해 'Fork()'라는 분기 기능을 쓸 수 있지만 이 경우 메모리를 2배로 잡아먹어, 용량부족에 따른 오류와 원인을 알수 없는 장애를 낼 수 있다. 이어지는 효과로, RDB 작업이 실패하면 '쓰기 거부' 상태가 돼 추가 장애를 낼 수 있다.

 메모리상의 정보를 디스크에 저장한다는 점은 RDB와 비슷하나, AOF는 레디스 프로토콜로 통신한 내용들을 명령어, 키, 이름 등 형식 그대로 저장한다는 점이 다르다. 다만 RDB 사용시 주의사항은 AOF에도 동일하게 적용된다.

복제(리플리케이션) 시스템을 구성해 가용성을 높이는 방법에 대한 주의사항으로 레디스의 '마스터'와 '슬레이브'라는 개념과 관리 요령을 숙지해야 한다.

 레디스 시스템에서 슬레이브는 이름처럼 마스터의 데이터 저장을 보조한다. 마스터가 죽었다가 되살아날 때 자신의 정보를 모두 없애고 그 데이터를 그대로 베낀다. 별도 조치 없이 아무 데이터가 없는 마스터를 시스템에 연결하면 슬레이브에 남은 데이터를 마스터에 되살릴 수 없다는 점이 포인트다. 이를 피하려면 복구할 데이터를 가진 시스템에 '슬레이브오브노원'이라는 명령어를 줘서 그걸 마스터로 승격시켜야 한다.

 카카오가 이 모든 레디스 분산환경에 대한 운영관리 요령을 엔지니어 개인에게 수작업으로 하게 하진 않는다. 장애시 복구를 위한 리플리케이션 작업을 '레디스센티넬'이라는 기술로 자동화할 수 있다. 하지만 레디스센티넬도 레디스 시스템만큼이나 사용시 주의사항이 많았다.

 레디스센티넬은 레디스 시스템에서 마스터가 죽었다고 판단시 다른 슬레이브를 마스터로 승격하고 사용자측에 마스터가 바뀌었다는 알림을 보내는 도구인데, 사실 미성숙한 기술인 것 같고 적당한 대안도 없다 며 레디스가 살았는지 판단하는 몇가지 단계(네트워크 단절, 주관적 다운, 객관적 다운)를 거쳐 페일오버(장애시 정상시스템으로 전환)를 수행한다.

+) 레디스 버전을 4.0.6이상으로 유지해야 한다. 그 밑 버전에서는 레디스 키가 저장 가능한 정수형을 넘어 장애가 발생할 수 있다. 그 이상 버전에서는 언사인드 롱을 사용해 키 용량이 널널하다. 최근 발생했던 커머스 전면장애의 원인이라는 썰이 있다. [관련 issue](https://github.com/antirez/redis/issues/4493)

> 출처: http://m.zdnet.co.kr/news_view.asp?article_id=20131119174125&re=zdk#imadnews
