# 레디스(redis)

## 사용시 주의 할점
레디스는 인메모리에서 돌아가는 NoSQL 데이터베이스(DB)로 '멤캐시드'와 경쟁구도를 그려 왔다.

레디스의 특징은 '싱글 쓰레드'라는 점이다. 싱글 쓰레드는 1번에 1개의 명령어만 실행할 수 있다. 한 서비스에서 요청된 명령어에 대한 작업이 끝나기 전까진 다른 서비스에서 요청하는 명령을 못 받아들인다. 이 특성 때문에 레디스로 웹서비스를 관리할 경우 절대 쓰면 안 되는 명령어들이 몇 가지 있다. 저장된 모든 키를 보여주는 명령어(keys)나 모든 데이터를 소거하는 명령어(flushall) 등이다.

모든 키를 보여주거나 플러싱하는 명령어는 테스트 환경이나 소량의 데이터를 관리하는 시스템에서 모니터링하는 용도로만 써야 한다 며 실행 대상을 전수처리하기 때문에 점차 데이터를 쌓아가는 환경에서는 운영에 차질을 빚을 정도로 속도가 느려질 것이다.
이어 빠른 속도로 플러시라는 명령어를 지원하는 멤캐시드 때문에 사람들이 레디스에서도 이 명령어가 금방 처리될 거라 기대하기도 하는데 실제 작동하는 방식이 완전히 다르다. 이 명령어 수행 시간을 재 보면 멤캐시드는 항상 일정하게 1~2ms가 나오는데 레디스는 데이터 100만건 정도 기준으로 1초(1천ms)로 이미 훨씬 느리다, 이건 실패한 사용법 이다.

레디스는 인메모리DB라 빠른 속도가 강점이지만 큰 용량의 데이터를 담기엔 공간 제약이 크다. 그래서 실시간 처리는 인메모리에서, 보관은 디스크 기반 스토리지로 하는 구조가 성능과 효율을 함께 달성할 수 있다. 트위터, 인스타그램, 페이스북처럼 대규모 사용자 기반을 갖춘 인터넷 서비스 업체들도 이런 식으로 서비스를 설계했다.

 레디스는 32비트 환경에선 최대 3GB 메모리만 사용 가능하고 64비트 시스템에서는 그런 제약이 없어 운영체제(OS)의 가상메모리(스왑)까지 쓴다. 하지만 이 경우 시스템의 메모리 한계를 인식하지 못해 더 많은 메모리를 요구하다가 문제를 일으킬 수 있어 관리자가 따로 설정을 더해줘야 한다.

 레디스는 멤캐시드에서 지원 안 하는 명령어 '콜렉션'을 지원하지만 앞서 '플러시올'이나 '키즈'같이 싱글쓰레드 방식에서 쓰지 말아야 하는 기능에 해당한다. 콜렉션에 데이터 100만건을 넣으면 처리시간이 10초, 1천만건 넣으면 100초씩 걸리는 식으로 늘어나기 때문에 굳이 쓰려면 일단 데이터를 1만건 미만으로 관리해야 한다.

이어 레디스에서 디스크에 메모리 상태를 그대로 받아 저장하는(메모리스냅숏) RDB 기능이 레디스 서버 장애요인 99.9%를 차지한다 며 원한다면 이 기능을 그냥 꺼 둘 수 있다.

 아마존 웹서비스 서버 기준으로 60GB짜리 메모리 서버 테스트시 RDB 작업에 10분 정도가 걸린다. 싱글쓰레드 문제를 겪지 않기 위해 'Fork()'라는 분기 기능을 쓸 수 있지만 이 경우 메모리를 2배로 잡아먹어, 용량부족에 따른 오류와 원인을 알수 없는 장애를 낼 수 있다. 이어지는 효과로, RDB 작업이 실패하면 '쓰기 거부' 상태가 돼 추가 장애를 낼 수 있다.

 메모리상의 정보를 디스크에 저장한다는 점은 RDB와 비슷하나, AOF는 레디스 프로토콜로 통신한 내용들을 명령어, 키, 이름 등 형식 그대로 저장한다는 점이 다르다. 다만 RDB 사용시 주의사항은 AOF에도 동일하게 적용된다.

복제(리플리케이션) 시스템을 구성해 가용성을 높이는 방법에 대한 주의사항으로 레디스의 '마스터'와 '슬레이브'라는 개념과 관리 요령을 숙지해야 한다.

 레디스 시스템에서 슬레이브는 이름처럼 마스터의 데이터 저장을 보조한다. 마스터가 죽었다가 되살아날 때 자신의 정보를 모두 없애고 그 데이터를 그대로 베낀다. 별도 조치 없이 아무 데이터가 없는 마스터를 시스템에 연결하면 슬레이브에 남은 데이터를 마스터에 되살릴 수 없다는 점이 포인트다. 이를 피하려면 복구할 데이터를 가진 시스템에 '슬레이브오브노원'이라는 명령어를 줘서 그걸 마스터로 승격시켜야 한다.

 카카오가 이 모든 레디스 분산환경에 대한 운영관리 요령을 엔지니어 개인에게 수작업으로 하게 하진 않는다. 장애시 복구를 위한 리플리케이션 작업을 '레디스센티넬'이라는 기술로 자동화할 수 있다. 하지만 레디스센티넬도 레디스 시스템만큼이나 사용시 주의사항이 많았다.

 레디스센티넬은 레디스 시스템에서 마스터가 죽었다고 판단시 다른 슬레이브를 마스터로 승격하고 사용자측에 마스터가 바뀌었다는 알림을 보내는 도구인데, 사실 미성숙한 기술인 것 같고 적당한 대안도 없다 며 레디스가 살았는지 판단하는 몇가지 단계(네트워크 단절, 주관적 다운, 객관적 다운)를 거쳐 페일오버(장애시 정상시스템으로 전환)를 수행한다.

+) 레디스 버전을 4.0.6이상으로 유지해야 한다. 그 밑 버전에서는 레디스 키가 저장 가능한 정수형을 넘어 장애가 발생할 수 있다. 그 이상 버전에서는 언사인드 롱을 사용해 키 용량이 널널하다. 최근 발생했던 커머스 전면장애의 원인이라는 썰이 있다. [관련 issue](https://github.com/antirez/redis/issues/4493)

> 출처: http://m.zdnet.co.kr/news_view.asp?article_id=20131119174125&re=zdk#imadnews
